
def n : Int := 1


def reflexivity {X : Type} {x : X} (p : x = x) := Eq.refl p


def symmetry {X : Type} {x : X} {y : X}  (p : x = y) := Eq.symm p


def transitivity {X : Type} {x : X} {y : X} {z : X} (p : x = y) (q : y = z) := Eq.trans p q


def extensionality (f g : X ‚Üí Y) (p : (x:X) ‚Üí f x = g x) : f = g := funext p


def equal_arguments {X : Type} {Y : Type} {a : X} {b : X} (f : X ‚Üí Y) (p : a = b) : f a = f b := congrArg f p

def equal_functions {X : Type} {Y : Type} {f‚ÇÅ : X ‚Üí Y} {f‚ÇÇ : X ‚Üí Y} (p : f‚ÇÅ = f‚ÇÇ) (x : X) : f‚ÇÅ x = f‚ÇÇ x := congrFun p x

def pairwise {A : Type} {B : Type} (a‚ÇÅ : A) (a‚ÇÇ : A) (b‚ÇÅ : B) (b‚ÇÇ : B) (p : a‚ÇÅ = a‚ÇÇ) (q : b‚ÇÅ = b‚ÇÇ) : (a‚ÇÅ,b‚ÇÅ)=(a‚ÇÇ,b‚ÇÇ) := (congr ((congrArg Prod.mk) p) q)


-- A category C consists of:
structure category.{u‚ÇÄ,v‚ÇÄ} where
  Obj : Type u‚ÇÄ
  Hom : Obj ‚Üí Obj ‚Üí Type v‚ÇÄ
  Idn : (X:Obj) ‚Üí Hom X X
  Cmp : (X:Obj) ‚Üí (Y:Obj) ‚Üí (Z:Obj) ‚Üí (_:Hom X Y) ‚Üí (_:Hom Y Z) ‚Üí Hom X Z
  Id‚ÇÅ : (X:Obj) ‚Üí (Y:Obj) ‚Üí (f:Hom X Y) ‚Üí
    Cmp X Y Y f (Idn Y) = f
  Id‚ÇÇ : (X:Obj) ‚Üí (Y:Obj) ‚Üí (f:Hom X Y) ‚Üí
    Cmp X X Y (Idn X) f = f
  Ass : (W:Obj) ‚Üí (X:Obj) ‚Üí (Y:Obj) ‚Üí (Z:Obj) ‚Üí (f:Hom W X) ‚Üí (g:Hom X Y) ‚Üí (h:Hom Y Z) ‚Üí
    (Cmp W X Z) f (Cmp X Y Z g h) = Cmp W Y Z (Cmp W X Y f g) h


-- Notation for the identity map which infers the category:
def identity_map (C : category) (X : C.Obj) := C.Idn X
notation "ùüô_(" C ")" => identity_map C



-- Notation for composition which infers the category and objects:
def composition (C : category) {X : C.Obj} {Y : C.Obj} {Z : C.Obj} (f : C.Hom X Y) (g : C.Hom Y Z) : C.Hom X Z := C.Cmp X Y Z f g
notation g "‚àò_(" C ")" f => composition C f g


theorem Id‚ÇÅ {C : category} {X : C.Obj} { Y : C.Obj} {f : C.Hom X Y} :
  (f ‚àò_(C) (ùüô_(C) X)) = f := C.Id‚ÇÇ X Y f

theorem Id‚ÇÇ {C : category} {X Y : C.Obj} {f : C.Hom X Y} :
  (ùüô_(C) Y ‚àò_(C) f) = f := C.Id‚ÇÅ X Y f

theorem Ass {C : category} {W X Y Z : C.Obj} {f : C.Hom W X} {g : C.Hom X Y} {h : C.Hom Y Z} :
  ((h ‚àò_(C) g) ‚àò_(C) f) = (h ‚àò_(C) (g ‚àò_(C) f)) := (C.Ass W X Y Z f g h)


macro "cat" : tactic => `(tactic| repeat (rw [Id‚ÇÅ]) ; repeat (rw [Id‚ÇÇ]) ; repeat (rw [Ass]))

example {C : category}
          {W : C.Obj}
          {X : C.Obj}
          {Y : C.Obj}
          {Z : C.Obj}
          {f : C.Hom W X}
          {g : C.Hom X Y}
          {h : C.Hom Y Z}
          {i : C.Hom Z W}:
     (i ‚àò_(C) (h ‚àò_(C) (g ‚àò_(C) (f ‚àò_(C) (ùüô_(C) W))) ))
  = ((i ‚àò_(C)  h) ‚àò_(C) ((ùüô_(C) Y) ‚àò_(C) g)) ‚àò_(C) (f) := by cat

‚Ñµ·∂ú·µÉ·µó
·µÉ	·µá	·∂ú	·µà	·µâ	·∂†	·µç	 ∞	‚Å±	 ≤	·µè	À°	·µê	‚Åø	·µí	·µñ	êû•	 ≥	À¢	·µó	·µò	·µõ	 ∑	À£	 ∏	·∂ª

-- obtaining a morphism from an equality
def Map (C : category) {X : C.Obj} {Y : C.Obj} (p : X = Y) : C.Hom X Y := by
subst p
exact ùüô_(C) X


notation "Map_(" C ")" p => Map C p


-- definition of an isomorphism from X to Y
structure isomorphism (C : category) (X : C.Obj) (Y : C.Obj) where
  Fst : C.Hom X Y
  Snd : C.Hom Y X
  Id‚ÇÅ : (C.Cmp X Y X Fst Snd) = C.Idn X
  Id‚ÇÇ : (C.Cmp Y X Y Snd Fst) = C.Idn Y


-- notation for isomorphisms from X to Y (‚âÖ)
notation X "‚âÖ_(" C ")" Y => isomorphism C X Y


-- defining the inverse of an isomorphism between objects X and Y
def inverse {C : category} {X : C.Obj} {Y : C.Obj} (f : X ‚âÖ_(C) Y) : Y ‚âÖ_(C) X := {Fst := f.Snd, Snd := f.Fst, Id‚ÇÅ := f.Id‚ÇÇ, Id‚ÇÇ := f.Id‚ÇÅ}


-- notation for inverse : isos from X to Y to isos from Y to X
notation f "‚Åª¬π" => inverse f


def SetObj := Type

def SetHom (X : SetObj) (Y : SetObj) : Type := X ‚Üí Y

def SetIdn (X : SetObj) : (SetHom X X) := Œª (x : X) => x


def SetCmp (X : SetObj) (Y : SetObj) (Z : SetObj) (f : SetHom X Y) (g : SetHom Y Z) : SetHom X Z := Œª (x : X) => (g (f x))


def SetId‚ÇÅ (X : SetObj) (Y : SetObj) (f : SetHom X Y) : (SetCmp X Y Y f (SetIdn Y)) = f := funext (Œª _ => rfl)

def SetId‚ÇÇ (X : SetObj) (Y : SetObj) (f : SetHom X Y) : (SetCmp X X Y (SetIdn X) f) = f := rfl

def SetAss (W : SetObj) (X : SetObj) (Y : SetObj) (Z : SetObj) (f : SetHom W X) (g : SetHom X Y) (h : SetHom Y Z) : (SetCmp W X Z f (SetCmp X Y Z g h)) = (SetCmp W Y Z (SetCmp W X Y f g) h) := funext (Œª _ => rfl)


def Set : category := {Obj := SetObj, Hom := SetHom, Idn := SetIdn, Cmp := SetCmp, Id‚ÇÅ := SetId‚ÇÅ, Id‚ÇÇ := SetId‚ÇÇ, Ass := SetAss}


-- definition of a functor
structure functor (C : category) (D : category) where
   Obj : ‚àÄ(_ : C.Obj),D.Obj
   Hom : ‚àÄ(X : C.Obj),‚àÄ(Y : C.Obj),‚àÄ(_ : C.Hom X Y),D.Hom (Obj X) (Obj Y)
   Idn : ‚àÄ(X : C.Obj),Hom X X (C.Idn X) = D.Idn (Obj X)
   Cmp : ‚àÄ(X : C.Obj),‚àÄ(Y : C.Obj),‚àÄ(Z : C.Obj),‚àÄ(f : C.Hom X Y),‚àÄ(g : C.Hom Y Z),
   D.Cmp (Obj X) (Obj Y) (Obj Z) (Hom X Y f) (Hom Y Z g) = Hom X Z (C.Cmp X Y Z f g)


--https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dependent.20type.20hell.20golfing.20challenge






-- definition of the identity functor on objects
def CatIdnObj (C : category) :=
fun(X : C.Obj)=>
X

-- definition of the identity functor on morphisms
def CatIdnMor (C : category) :=
fun(X : C.Obj)=>
fun(Y : C.Obj)=>
fun(f : C.Hom X Y)=>
f

-- proving the identity law for the identity functor
def CatIdnIdn (C : category) :=
fun(X : C.Obj)=>
Eq.refl (C.Idn X)

-- proving the compositionality law for the identity functor
def CatIdnCmp (C : category) :=
fun(X : C.Obj)=>
fun(Y : C.Obj)=>
fun(Z : C.Obj)=>
fun(f : C.Hom X Y)=>
fun(g : C.Hom Y Z)=>
Eq.refl (C.Cmp X Y Z f g)


-- defining the identity functor
def CatIdn (C : category) : functor C C :=
{Obj := CatIdnObj C, Hom := CatIdnMor C, Idn := CatIdnIdn C, Cmp := CatIdnCmp C}


-- defining the composition G ‚àò_(Cat) F on objects
def CatCmpObj (C : category) (D : category) (E : category) (F : functor C D) (G : functor D E) :=
fun(X : C.Obj)=>
(G.Obj (F.Obj X))

-- defining the composition G ‚àò_(Cat) F on morphisms
def CatCmpHom (C : category) (D : category) (E : category) (F : functor C D) (G : functor D E) :=
fun(X : C.Obj)=>
fun(Y : C.Obj)=>
fun(f : C.Hom X Y)=>
(G.Hom) (F.Obj X) (F.Obj Y) (F.Hom X Y f)


-- proving the identity law for the composition G ‚àò_(Cat) F
def CatCmpIdn (C : category) (D : category) (E : category) (F : functor C D) (G : functor D E) :=
fun(X : C.Obj)=>
Eq.trans (congrArg (G.Hom (F.Obj X) (F.Obj X)) (F.Idn X) ) (G.Idn (F.Obj X))


-- proving the compositionality law for the composition G ‚àò_(Cat) F
def CatCmpCmp (C : category) (D : category) (E : category) (F : functor C D) (G : functor D E) :=
fun(X : C.Obj)=>
fun(Y : C.Obj)=>
fun(Z : C.Obj)=>
fun(f : C.Hom X Y)=>
fun(g : C.Hom Y Z)=>
((Eq.trans)
(G.Cmp (F.Obj X) (F.Obj Y) (F.Obj Z) (F.Hom X Y f) (F.Hom Y Z g))
(congrArg (G.Hom  (F.Obj X) (F.Obj Z)) (F.Cmp X Y Z f g)))


-- defining the composition in the category Cat
def CatCmp (C : category) (D : category) (E : category) (F : functor C D) (G : functor D E) : functor C E :=
{Obj := CatCmpObj C D E F G, Hom := CatCmpHom C D E F G,Idn := CatCmpIdn C D E F G, Cmp := CatCmpCmp C D E F G}


-- proving Cat.Id‚ÇÅ
def CatId‚ÇÅ (C : category) (D : category) (F : functor C D) : ((CatCmp C D D) F (CatIdn D) = F) := Eq.refl F

-- Proof of Cat.Id‚ÇÇ
def CatId‚ÇÇ (C : category) (D : category) (F : functor C D) : ((CatCmp C C D) (CatIdn C) F = F) := Eq.refl F

-- Proof of Cat.Ass
def CatAss (B : category) (C : category) (D : category) (E : category) (F : functor B C) (G : functor C D) (H : functor D E) : (CatCmp B C E F (CatCmp C D E G H) = CatCmp B D E (CatCmp B C D F G) H) :=
Eq.refl (CatCmp B C E F (CatCmp C D E G H))


-- The category of categories
universe u
universe v
def Cat : category := {Obj := category.{u, v}, Hom := functor, Idn := CatIdn, Cmp := CatCmp, Id‚ÇÅ:= CatId‚ÇÅ, Id‚ÇÇ:= CatId‚ÇÇ, Ass := CatAss}


notation "ùüô" X => ùüô_(Cat) X

notation g "‚àò" f => g ‚àò_(Cat) f


-- defining the objects of the CatPrd C D
def CatPrdObj (C : category) (D : category) := (D.Obj) √ó (C.Obj)

-- defining the morphisms of CatPrd C D
def CatPrdHom (C : category) (D : category) (X : CatPrdObj C D) (Y : CatPrdObj C D) := (D.Hom X.1 Y.1) √ó (C.Hom X.2 Y.2)

-- defining the identity functor on an object in C √ó D
def CatPrdIdn (C : category) (D : category) (X : CatPrdObj C D) := ((D.Idn X.1),(C.Idn X.2))

-- defining the composition on morphisms in C √ó D
def CatPrdCmp (C : category) (D : category) (X : CatPrdObj C D) (Y : CatPrdObj C D) (Z : CatPrdObj C D) (f : CatPrdHom C D X Y) (g : CatPrdHom C D Y Z) : CatPrdHom C D X Z := (D.Cmp X.1 Y.1 Z.1 f.1 g.1, C.Cmp X.2 Y.2 Z.2 f.2 g.2)


-- proving the first identity law for morphisms in C √ó_Cat D
theorem CatPrdId‚ÇÅ (C : category) (D : category) (X : CatPrdObj C D) (Y : CatPrdObj C D) (f : CatPrdHom C D X Y) :
  CatPrdCmp C D X Y Y f (CatPrdIdn C D Y) = f := sorry

-- proving the second identity law for morphisms in C √ó_Cat D
theorem CatPrdId‚ÇÇ (C : category) (D : category) (X : CatPrdObj C D) (Y : CatPrdObj C D) (f : CatPrdHom C D X Y) : CatPrdCmp C D X X Y (CatPrdIdn C D X) f = f := sorry

-- proving associativity for morphisms in C √ó_Cat D
theorem CatPrdAss
  (C : category) (D : category)
  (W : CatPrdObj C D) (X : CatPrdObj C D)
  (Y : CatPrdObj C D) (Z : CatPrdObj C D)
  (f : CatPrdHom C D W X) (g : CatPrdHom C D X Y) (h : CatPrdHom C D Y Z) :
  CatPrdCmp C D W X Z f (CatPrdCmp C D X Y Z g h) = CatPrdCmp C D W Y Z (CatPrdCmp C D W X Y f g) h := sorry


-- defining the CatPrd of two categories
def CatPrd (C : category) (D : category) : category := {Obj := CatPrdObj C D, Hom := CatPrdHom C D, Idn := CatPrdIdn C D, Cmp := CatPrdCmp C D, Id‚ÇÅ := CatPrdId‚ÇÅ C D, Id‚ÇÇ:= CatPrdId‚ÇÇ C D, Ass := CatPrdAss C D}


notation:1000  D "√ó_Cat" C => CatPrd C D


def FunPrdObj
  {C‚ÇÅ : category}
  {D‚ÇÅ : category}
  {C‚ÇÇ : category}
  {D‚ÇÇ : category}
  (F : Cat.Hom C‚ÇÅ D‚ÇÅ)
  (G : Cat.Hom C‚ÇÇ D‚ÇÇ) :
  (C‚ÇÅ √ó_Cat C‚ÇÇ).Obj ‚Üí (D‚ÇÅ √ó_Cat D‚ÇÇ).Obj :=
  sorry


def FunPrdHom
  {C‚ÇÅ : category}
  {D‚ÇÅ : category}
  {C‚ÇÇ : category}
  {D‚ÇÇ : category}
  (F : Cat.Hom C‚ÇÅ D‚ÇÅ)
  (G : Cat.Hom C‚ÇÇ D‚ÇÇ)
  (X : (C‚ÇÅ √ó_Cat C‚ÇÇ).Obj)
  (Y : (C‚ÇÅ √ó_Cat C‚ÇÇ).Obj)
  (f : (C‚ÇÅ √ó_Cat C‚ÇÇ).Hom X Y) :
  ((D‚ÇÅ √ó_Cat D‚ÇÇ).Hom (FunPrdObj F G X) (FunPrdObj F G Y) ) :=
  sorry


def FunPrdIdn
  {C‚ÇÅ : category}
  {D‚ÇÅ : category}
  {C‚ÇÇ : category}
  {D‚ÇÇ : category}
  (F : Cat.Hom C‚ÇÅ D‚ÇÅ)
  (G : Cat.Hom C‚ÇÇ D‚ÇÇ)
  (X : (C‚ÇÅ √ó_Cat C‚ÇÇ).Obj) :
  (FunPrdHom F G X X ((C‚ÇÅ √ó_Cat C‚ÇÇ).Idn X))  = ((D‚ÇÅ √ó_Cat D‚ÇÇ).Idn (FunPrdObj F G X)) :=
  sorry


def FunPrdCmp
  {C‚ÇÅ : category}
  {D‚ÇÅ : category}
  {C‚ÇÇ : category}
  {D‚ÇÇ : category}
  (F : Cat.Hom C‚ÇÅ D‚ÇÅ)
  (G : Cat.Hom C‚ÇÇ D‚ÇÇ)
  (X : (C‚ÇÅ √ó_Cat C‚ÇÇ).Obj)
  (Y : (C‚ÇÅ √ó_Cat C‚ÇÇ).Obj)
  (Z : (C‚ÇÅ √ó_Cat C‚ÇÇ).Obj)
  (f : (C‚ÇÅ √ó_Cat C‚ÇÇ).Hom X Y)
  (g : (C‚ÇÅ √ó_Cat C‚ÇÇ).Hom Y Z) :
  ((D‚ÇÅ √ó_Cat D‚ÇÇ).Cmp (FunPrdObj F G X) (FunPrdObj F G Y) (FunPrdObj F G Z) ((FunPrdHom F G) X Y f) (FunPrdHom F G Y Z g)) = (FunPrdHom F G X Z ((C‚ÇÅ √ó_Cat C‚ÇÇ).Cmp X Y Z f g)) :=
  sorry


def FunPrd
  {C‚ÇÅ : category}
  {D‚ÇÅ : category}
  {C‚ÇÇ : category}
  {D‚ÇÇ : category}
  (F : Cat.Hom C‚ÇÅ D‚ÇÅ)
  (G : Cat.Hom C‚ÇÇ D‚ÇÇ) :
  Cat.Hom (C‚ÇÅ √ó_Cat C‚ÇÇ) (D‚ÇÅ √ó_Cat D‚ÇÇ) :=
  {Obj := FunPrdObj F G, Hom := FunPrdHom F G, Idn := FunPrdIdn F G, Cmp := FunPrdCmp F G}


notation F "√ó_Fun" G => FunPrd F G


-- defining the category *_Cat
def PntObj : Type := Unit
def PntHom (_ : PntObj) (_ : PntObj) : Type := Unit
def PntIdn (X : PntObj) : PntHom X X := Unit.unit
def PntCmp (X : PntObj) (Y : PntObj) (Z : PntObj) (_ : PntHom X Y) (_ : PntHom Y Z) : PntHom X Z := Unit.unit
def PntId‚ÇÅ (X : PntObj) (Y : PntObj) (f : PntHom X Y) : PntCmp X Y Y f (PntIdn Y) = f := Eq.refl f
def PntId‚ÇÇ (X : PntObj) (Y : PntObj) (f : PntHom X Y) : PntCmp X X Y (PntIdn X) f = f := Eq.refl f
def PntAss (W : PntObj) (X : PntObj) (Y : PntObj) (Z : PntObj) (f : PntHom W X) (g : PntHom X Y) (h : PntHom Y Z) : PntCmp W Y Z (PntCmp W X Y f g) h = PntCmp W X Z f (PntCmp X Y Z g h) := Eq.refl Unit.unit
def Pnt : category := {Obj := PntObj, Hom := PntHom, Idn := PntIdn, Cmp := PntCmp, Id‚ÇÅ := PntId‚ÇÅ, Id‚ÇÇ := PntId‚ÇÇ, Ass := PntAss}


-- notation for the category *_Cat
notation "*_Cat" => Pnt


def PrdId‚ÇÅFst (C : category) : Cat.Hom C (C √ó_Cat *_Cat) := sorry

def PrdId‚ÇÅSnd (C : category) : Cat.Hom (C √ó_Cat *_Cat) C := sorry


def PrdId‚ÇÅId‚ÇÅ (C : category) : ((PrdId‚ÇÅSnd C) ‚àò_(Cat) (PrdId‚ÇÅFst C)) = ùüô_(Cat) C := sorry

def PrdId‚ÇÅId‚ÇÇ (C : category) : ((PrdId‚ÇÅFst C) ‚àò_(Cat) (PrdId‚ÇÅSnd C)) = ùüô_(Cat) (C √ó_Cat *_Cat) := sorry


def PrdId‚ÇÅ (C : category) :  C ‚âÖ_(Cat) (C √ó_Cat *_Cat)  := {Fst := PrdId‚ÇÅFst C, Snd:= PrdId‚ÇÅSnd C, Id‚ÇÅ := PrdId‚ÇÅId‚ÇÅ C, Id‚ÇÇ := PrdId‚ÇÅId‚ÇÇ C}


def PrdId‚ÇÇFst (C : category) : Cat.Hom C (*_Cat √ó_Cat C) := sorry

def PrdId‚ÇÇSnd (C : category) : Cat.Hom (*_Cat √ó_Cat C) C := sorry


def PrdId‚ÇÇId‚ÇÅ (C : category) : ((PrdId‚ÇÇSnd C) ‚àò_(Cat) (PrdId‚ÇÇFst C)) = ùüô_(Cat) C := sorry

def PrdId‚ÇÇId‚ÇÇ (C : category) : ((PrdId‚ÇÇFst C) ‚àò_(Cat) (PrdId‚ÇÇSnd C)) = ùüô_(Cat) (*_Cat √ó_Cat C) := sorry


def PrdId‚ÇÇ (C : category) :  C ‚âÖ_(Cat) (*_Cat √ó_Cat C)  := {Fst := PrdId‚ÇÇFst C, Snd:= PrdId‚ÇÇSnd C, Id‚ÇÅ := PrdId‚ÇÇId‚ÇÅ C, Id‚ÇÇ := PrdId‚ÇÇId‚ÇÇ C}


def PrdAssFst
  (C : category)
  (D : category)
  (E : category) :
  Cat.Hom (C √ó_Cat D √ó_Cat E) ((C √ó_Cat D) √ó_Cat E) := sorry

def PrdAssSnd
  (C : category)
  (D : category)
  (E : category) :
  Cat.Hom ((C √ó_Cat D) √ó_Cat E) (C √ó_Cat D √ó_Cat E) := sorry


def PrdAssId‚ÇÅ
  (C : category)
  (D : category)
  (E : category) : ((PrdAssSnd C D E) ‚àò_(Cat) (PrdAssFst C D E)) = ùüô_(Cat) (C √ó_Cat D √ó_Cat E) := sorry

def PrdAssId‚ÇÇ
  (C : category)
  (D : category)
  (E : category) :  ((PrdAssFst C D E) ‚àò_(Cat) (PrdAssSnd C D E)) = ùüô_(Cat) ((C √ó_Cat D) √ó_Cat E)  := sorry


def PrdAss
  (C : category)
  (D : category)
  (E : category) : (C √ó_Cat D √ó_Cat E)‚âÖ_(Cat) ((C √ó_Cat D) √ó_Cat E)    := {Fst := PrdAssFst C D E, Snd:= PrdAssSnd C D E, Id‚ÇÅ := PrdAssId‚ÇÅ C D E, Id‚ÇÇ := PrdAssId‚ÇÇ C D E}


-- definition of a (strict) twocategory
structure twocategory.{w} where
  Obj : Type w
  Hom : Obj ‚Üí
        Obj ‚Üí
        category
  Idn : (C : Obj) ‚Üí
        Cat.Hom *_Cat (Hom C C)
  Cmp : (C : Obj) ‚Üí
        (D : Obj) ‚Üí
        (E : Obj) ‚Üí
        Cat.Hom ((Hom C D) √ó_Cat (Hom D E)) (Hom C E)
  Id‚ÇÅ : (C : Obj) ‚Üí
        (D : Obj) ‚Üí
        ((Cmp C D D) ‚àò_(Cat) ((ùüô_(Cat) (Hom C D)) √ó_Fun (Idn D)) ‚àò_(Cat) (PrdId‚ÇÅ (Hom C D)).Fst) = (ùüô_(Cat) (Hom C D))
  Id‚ÇÇ : (C : Obj) ‚Üí
        (D : Obj) ‚Üí
        ((Cmp C C D) ‚àò_(Cat) ((Idn C) √ó_Fun (ùüô_(Cat) (Hom C D))) ‚àò_(Cat) (PrdId‚ÇÇFst (Hom C D))) = (ùüô_(Cat) (Hom C D))
  Ass : (B : Obj) ‚Üí
        (C : Obj) ‚Üí
        (D : Obj) ‚Üí
        (E : Obj) ‚Üí
        ((Cmp B C E) ‚àò_(Cat) ((ùüô_(Cat) (Hom B C)) √ó_Fun (Cmp C D E))) = (Cmp B D E) ‚àò_(Cat) ((Cmp B C D) √ó_Fun (ùüô_(Cat) (Hom D E))) ‚àò_(Cat) (PrdAss (Hom B C) (Hom C D) (Hom D E)).Fst


-- definition of a twofunctor
structure twofunctor (C : twocategory) (D : twocategory) where
  Obj : C.Obj ‚Üí D.Obj
  Hom : (X : C.Obj) ‚Üí (Y : C.Obj) ‚Üí (functor (C.Hom X Y) (D.Hom (Obj X) (Obj Y)))
-- Idn : (X : C.Obj) ‚Üí ()
-- Cmp : (X : C.Obj) ‚Üí (Y : C.Obj) ‚Üí (Z : C.Obj) ‚Üí


-- defining the identity component of the category TwoCat
def TwoCatIdn (C : twocategory) : (twofunctor C C) := sorry


-- defining the composition component of the category TwoCat
def TwoCatCmp (C : twocategory) (D : twocategory) (E : twocategory) (F : twofunctor C D) (G : twofunctor D E) : twofunctor C E := sorry


-- defining the first identity component of the category TwoCat
/-

-/


-- defining the second identity component of the category TwoCat
/-

-/


-- defining the associativity component of the category TwoCat
/-

-/


-- Assembling the category TwoCat
def TwoCat : category := sorry


-- Notation for the identity map which infers the category:
def twocategory_identity_map (C : twocategory) (X : C.Obj) : (C.Hom X X).Obj := ((C.Idn X).Obj Unit.unit)
notation "ùüè_(" C ")" => twocategory_identity_map C



-- Notation for composition in a twocategory which infers the category and objects:

def composition_on_objects (C : twocategory) {X : C.Obj} {Y : C.Obj} {Z : C.Obj} (f : (C.Hom X Y).Obj) (g : (C.Hom Y Z).Obj) : (C.Hom X Z).Obj := (C.Cmp X Y Z).Obj (f, g)
notation: 1000 g "‚Ä¢_(" C ")" f => composition_on_objects C f g

def TwoCmpObj {C : twocategory} {X : C.Obj} {Y : C.Obj} {Z : C.Obj} (f : (C.Hom X Y).Obj) (g : (C.Hom Y Z).Obj) : (C.Hom X Z).Obj :=  (C.Cmp X Y Z).Obj (f, g)
notation: 1000 g "‚Ä¢" f => TwoCmpObj f g


def composition_on_morphisms (C : twocategory) {X : C.Obj} {Y : C.Obj} {Z : C.Obj} {F‚ÇÅ : (C.Hom X Y).Obj} {F‚ÇÇ : (C.Hom X Y).Obj} {G‚ÇÅ : (C.Hom Y Z).Obj} {G‚ÇÇ : (C.Hom Y Z).Obj} (Œ∑ : (C.Hom X Y).Hom F‚ÇÅ F‚ÇÇ) (Œµ : (C.Hom Y Z).Hom G‚ÇÅ G‚ÇÇ) : (C.Hom X Z).Hom (G‚ÇÅ ‚Ä¢ F‚ÇÅ) (G‚ÇÇ ‚Ä¢ F‚ÇÇ) := (C.Cmp X Y Z).Hom (F‚ÇÅ,G‚ÇÅ) (F‚ÇÇ,G‚ÇÇ) (Œ∑,Œµ)
notation: 1000 g "‚àô_(" C ")" f => composition_on_morphisms C f g

def TwoCmpHom {C : twocategory} {X : C.Obj} {Y : C.Obj} {Z : C.Obj} {F‚ÇÅ : (C.Hom X Y).Obj} {F‚ÇÇ : (C.Hom X Y).Obj} {G‚ÇÅ : (C.Hom Y Z).Obj} {G‚ÇÇ : (C.Hom Y Z).Obj} (Œ∑ : (C.Hom X Y).Hom F‚ÇÅ F‚ÇÇ) (Œµ : (C.Hom Y Z).Hom G‚ÇÅ G‚ÇÇ) : (C.Hom X Z).Hom (G‚ÇÅ ‚Ä¢ F‚ÇÅ) (G‚ÇÇ ‚Ä¢ F‚ÇÇ) := (C.Cmp X Y Z).Hom (F‚ÇÅ,G‚ÇÅ) (F‚ÇÇ,G‚ÇÇ) (Œ∑,Œµ)
notation : 1000 g "‚àô" f => TwoCmpHom f g


/-
theorem Id‚ÇÅObj {C : category} {X : C.Obj} {Y : C.Obj} {f : C.Hom X Y} :
  (f ‚àò_(C) (ùüô_(C) X)) = f := C.Id‚ÇÇ X Y f

theorem Id‚ÇÅHom {C : category} {X : C.Obj} {Y : C.Obj} {f : C.Hom X Y} :
  (f ‚àò_(C) (ùüô_(C) X)) = f := C.Id‚ÇÇ X Y f

theorem Id‚ÇÇObj {C : category} {X Y : C.Obj} {f : C.Hom X Y} :
  (ùüô_(C) Y ‚àò_(C) f) = f := C.Id‚ÇÅ X Y f

theorem Id‚ÇÇHom {C : category} {X Y : C.Obj} {f : C.Hom X Y} :
  (ùüô_(C) Y ‚àò_(C) f) = f := C.Id‚ÇÅ X Y f

theorem AssObj {C : category} {W X Y Z : C.Obj} {f : C.Hom W X} {g : C.Hom X Y} {h : C.Hom Y Z} :
  ((h ‚àò_(C) g) ‚àò_(C) f) = (h ‚àò_(C) (g ‚àò_(C) f)) := (C.Ass W X Y Z f g h)

theorem AssHom {C : category} {W X Y Z : C.Obj} {f : C.Hom W X} {g : C.Hom X Y} {h : C.Hom Y Z} :
  ((h ‚àò_(C) g) ‚àò_(C) f) = (h ‚àò_(C) (g ‚àò_(C) f)) := (C.Ass W X Y Z f g h)
-/


/-
theorem CmpHom
-/


/-
macro "twocat" : tactic => `(tactic| repeat (rw [Id‚ÇÅObj]) ; repeat (rw [Id‚ÇÅHom]) ; repeat (rw [Id‚ÇÇObj]) ; repeat (rw [Id‚ÇÇHom]); repeat (rw [AssObj])) ; repeat (rw [AssHom]))

-- example of the cat tactic
example {C : category}
          {W : C.Obj}
          {X : C.Obj}
          {Y : C.Obj}
          {Z : C.Obj}
          {A : C.Obj}
          {f : C.Hom W X}
          {g : C.Hom X Y}
          {h : C.Hom Y Z}
          {i : C.Hom Z A}:
     (i ‚àò_(C) (h ‚àò_(C) (g ‚àò_(C) (f ‚àò_(C) (ùüô_(C) W))) ))
  = ((i ‚àò_(C)  h) ‚àò_(C) ((ùüô_(C) Y) ‚àò_(C) g)) ‚àò_(C) (f) := by cat
-/


-- obtaining a morphism from an equality
def TwoMap (C : twocategory) {X : C.Obj} {Y : C.Obj} (p : X = Y) : (C.Hom X Y).Obj := by
subst p
exact ùüè_(C) X


notation "TwoMap_(" C ")" p => TwoMap C p


-- definition of an equivalence from X to Y
structure equivalence (T : twocategory) (X : T.Obj) (Y : T.Obj) where
  Fst : (T.Hom X Y).Obj
  Snd : (T.Hom Y X).Obj
  Id‚ÇÅ : (T.Cmp X Y X).Obj (Fst,Snd) ‚âÖ_(T.Hom X X) (ùüè_(T) X)
  Id‚ÇÇ : (T.Cmp Y X Y).Obj (Snd,Fst) ‚âÖ_(T.Hom Y Y) (ùüè_(T) Y)


-- notation for equivalences from C to D (‚âÉ)
notation C "‚âÉ_(" T ")" D => equivalence T C D


-- defining the inverse of an isomorphism between objects X and Y
/-
def twocategory_inverse {C : category} {X : C.Obj} {Y : C.Obj} (f : X ‚âÖ_(C) Y) : Y ‚âÖ_(C) X := {Fst := f.Snd, Snd := f.Fst, Id‚ÇÅ := f.Id‚ÇÇ, Id‚ÇÇ := f.Id‚ÇÅ}
-/


-- notation for inverse of an equivalence : isos from X to Y to isos from Y to X
-- notation f "‚Åª¬π" => inverse f


-- defining natural transformations for a category C and a category D
structure HomHom (C : category.{u,v}) (D : category.{u,v}) (F : functor C D) (G : functor C D) where
  Obj : (X : C.Obj) ‚Üí (D.Hom (F.Obj X) (G.Obj X))
  Nat : (X : C.Obj) ‚Üí (Y : C.Obj) ‚Üí (f : C.Hom X Y) ‚Üí (D.Cmp (F.Obj X) (F.Obj Y) (G.Obj Y) (F.Hom X Y f) (Obj Y)) = (D.Cmp (F.Obj X) (G.Obj X) (G.Obj Y) (Obj X) (G.Hom X Y f))


-- notation for natural transformations
def natural_transformation {C : category.{u,v}} {D : category.{u,v}} (F : functor C D) (G : functor C D) := HomHom C D F G


-- defining (C ‚Üí_Cat D).Idn.Obj, the identity natural transformation of a functor on objects
def HomIdnObj (C : category.{u,v}) (D : category.{u,v}) (F : functor C D) (X : C.Obj) : (D.Hom (F.Obj X) (F.Obj X)) := D.Idn (F.Obj X)


-- helping to prove the naturality of the identity functor
def HomIdnNat‚ÇÅ (C : category.{u,v}) (D : category.{u,v}) (F : functor C D) (X : C.Obj) (Y : C.Obj) (f : C.Hom X Y) : (D.Cmp (F.Obj X) (F.Obj Y) (F.Obj Y) (F.Hom X Y f) (HomIdnObj C D F Y)) = F.Hom X Y f := D.Id‚ÇÅ (functor.Obj F X) (functor.Obj F Y) (functor.Hom F X Y f)

-- starting to prove the naturality of the identity functor
def HomIdnNat‚ÇÇ (C : category.{u,v}) (D : category.{u,v}) (F : functor C D) (X : C.Obj) (Y : C.Obj) (f : C.Hom X Y) : (D.Cmp (F.Obj X) (F.Obj X) (F.Obj Y) (HomIdnObj C D F X) (F.Hom X Y f)) = F.Hom X Y f := D.Id‚ÇÇ (functor.Obj F X) (functor.Obj F Y) (functor.Hom F X Y f)

-- proving the naturality of the identity functor, (C ‚Üí_Cat D).Idn.Nat
def HomIdnNat (C : category.{u,v}) (D : category.{u,v}) (F : functor C D) (X : C.Obj) (Y : C.Obj) (f : C.Hom X Y) : (D.Cmp (F.Obj X) (F.Obj Y) (F.Obj Y) (F.Hom X Y f) (HomIdnObj C D F Y)) = (D.Cmp (F.Obj X) (F.Obj X) (F.Obj Y) (HomIdnObj C D F X) (F.Hom X Y f)) := Eq.trans (HomIdnNat‚ÇÅ C D F X Y f) (Eq.symm (HomIdnNat‚ÇÇ C D F X Y f))


-- defining (C ‚Üí_Cat D).Idn for a category C and a category D
def HomIdn (C : category.{u,v}) (D : category.{u,v}) (F : Cat.Hom C D) : HomHom C D F F := {Obj := HomIdnObj C D F, Nat := HomIdnNat C D F}


-- defining composition of natural transformations
def HomCmpObj (C : category.{u,v}) (D : category.{u,v}) (F : functor C D) (G : functor C D) (H : functor C D) (f : HomHom C D F G) (g : HomHom C D G H) (X : C.Obj) :  D.Hom (F.Obj X) (H.Obj X) := (g.Obj X) ‚àò_(D) (f.Obj X)

-- defining composition of natural transformations
def HomCmpNat (C : category.{u,v}) (D : category.{u,v}) (F : functor C D) (G : functor C D) (H : functor C D) (f : HomHom C D F G) (g : HomHom C D G H) (X : C.Obj) (Y : C.Obj) (Œ± : C.Hom X Y) : (((g.Obj Y) ‚àò_(D) (f.Obj Y)) ‚àò_(D) (F.Hom X Y Œ±))  = ((H.Hom X Y Œ±) ‚àò_(D) ((g.Obj X) ‚àò_(D) (f.Obj X)))  := sorry

-- defining composition of natural transformations
def HomCmp (C : category.{u,v}) (D : category.{u,v}) (F : functor C D) (G : functor C D) (H : functor C D) (f : HomHom C D F G) (g : HomHom C D G H) : HomHom C D F H := {Obj := HomCmpObj C D F G H f g, Nat := HomCmpNat C D F G H f g}


-- proving the identity laws and associativity for the category C ‚Üí_Cat D

-- proving the first identity law of the functor category C ‚Üí_Cat D
def HomId‚ÇÅ (C : category.{u,v}) (D : category.{u,v}) (F : functor C D) (G : functor C D) (f : HomHom C D F G) : HomCmp C D F G G f (HomIdn C D G) = f := sorry

-- proving the second identity law of the functor category C ‚Üí_Cat D
def HomId‚ÇÇ (C : category.{u,v}) (D : category.{u,v}) (F : functor C D) (G : functor C D) (f : HomHom C D F G) : HomCmp C D F F G (HomIdn C D F) f = f := sorry

-- proving associativity of the functor category C ‚Üí_Cat D
def HomAss (C : category.{u,v}) (D : category.{u,v}) (F : functor C D) (G : functor C D) (H : functor C D) (I : functor C D) (Œ± : HomHom C D F G) (Œ≤ : HomHom C D G H) (Œ≥ : HomHom C D H I) : (HomCmp C D F G I Œ± (HomCmp C D G H I Œ≤ Œ≥)) = (HomCmp C D F H I (HomCmp C D F G H Œ± Œ≤) Œ≥) := sorry


-- defining the category C ‚Üí_Cat D for a category C and a category D
def ‚ÑÇùïíùï•Hom (C : category) (D : category) : category := sorry -- {Obj := functor C D, Hom := HomHom C D, Idn := HomIdn C D, Cmp := HomCmp C D, Id‚ÇÅ := HomId‚ÇÅ C D, Id‚ÇÇ := HomId‚ÇÇ C D, Ass := HomAss C D}


-- defining categories.Idn.Obj
-- def CatIdnObj (C : category) (_ : Unit) := Cat.Idn C


-- defining the functor categories.Idn.Hom on morphisms
-- def categoriesIdnHom (C : category) (_ : Unit) (_ : Unit) (_: Unit) := (Hom C C).Idn (Cat.Idn C)


-- proving the identity law for the functor categories.TwoIdn
-- def TwoIdnIdn (C : category) (_ : Unit) (_ : Unit) (_: Unit) := (Hom C C).Idn (Cat.Idn C)


-- proving compositionality for the functor categories.TwoIdn
-- def Two.Idn.Cmp (C : category) (_ : Unit) (_ : Unit) (_: Unit) := (Hom C C).Idn (Cat.Idn C)


-- def ‚ÑÇùïíùï•.Idn
def ‚ÑÇùïíùï•Idn (C : category) : Cat.Hom *_Cat (‚ÑÇùïíùï•Hom C C) := sorry


--  defining ‚ÑÇùïíùï•.Cmp.Obj
/-
-/


--  defining ‚ÑÇùïíùï•.Cmp.Hom
/-
def categoriesTwoHom (C : Obj) (D : Obj) (E : Obj) : FG.1 FG.2
def categoriesTwoHom (C : Obj) (D : Obj) (E : Obj) (f : ((Hom C D) √ó (Hom D E)).Hom )
def CatsHom (C : Obj) (D : Obj) (E : Obj)
(F‚ÇÅG‚ÇÅ : ((Hom C D) √ó (Hom D E)).Obj) (F‚ÇÇG‚ÇÇ : ((Hom C D) √ó (Hom D E)).Obj)
-/



-- defining the horizontal composition of natural transformations
-- def horizontal_composition {C : category} {D : category} {E : category} {F‚ÇÅ : C ‚Üí D} {F‚ÇÇ : C ‚Üí D} {G‚ÇÅ : D ‚Üí E} {G‚ÇÇ : D ‚Üí E} (Œ∑‚ÇÅ : F‚ÇÅ ‚á® F‚ÇÇ) (Œ∑‚ÇÇ : G‚ÇÅ ‚á® G‚ÇÇ) : ((Cat.Cmp C D E F‚ÇÅ G‚ÇÅ) ‚á® (Cat.Cmp C D E F‚ÇÇ G‚ÇÇ)) := sorry


-- notation for the horizontal composition of natural transformations
-- notation Œ∑‚ÇÇ "‚àô" Œ∑‚ÇÅ => horizontal_composition Œ∑‚ÇÅ Œ∑‚ÇÇ


-- proving the identity law equation for ‚ÑÇùïíùï•.Cmp
/-
-- def CmpIdn :
-/


-- proving compositionality for the functor ‚ÑÇùïíùï•.Cmp
-- def CmpCmp : (C : category) ‚Üí (D : category) ‚Üí (E : category) ‚Üí (CatPrd (Hom C D) (Hom D E)) ‚Üí (Hom C E) := sorry


--  categories.Cmp : (C : Obj) ‚Üí (D : Obj) ‚Üí (E : Obj) ‚Üí (Hom C D) √ó (Hom D E) ‚Üí (Hom C E)
def ‚ÑÇùïíùï•Cmp : (C : category.{u,v}) ‚Üí (D : category.{u,v}) ‚Üí (E : category.{u,v}) ‚Üí functor ((‚ÑÇùïíùï•Hom C D) √ó_Cat (‚ÑÇùïíùï•Hom D E)) (‚ÑÇùïíùï•Hom C E) := sorry


--  Id‚ÇÅ : (C : Obj) ‚Üí (D : Obj) ‚Üí (Cats.Id‚ÇÅ)
/-
def Id‚ÇÅ : (C : category) ‚Üí (D : category) ‚Üí (F : functor C D) ‚Üí
-/

def ‚ÑÇùïíùï•Id‚ÇÅ :  ‚àÄ (C D : category.{u,v}),
  ((‚ÑÇùïíùï•Cmp C D D)‚àò_(Cat)(ùüô_(Cat) (‚ÑÇùïíùï•Hom C D) √ó_Fun ‚ÑÇùïíùï•Idn D)‚àò_(Cat)(PrdId‚ÇÅ (‚ÑÇùïíùï•Hom C D)).Fst) =
  ùüô_(Cat) (‚ÑÇùïíùï•Hom C D) := sorry




--
def ‚ÑÇùïíùï•Id‚ÇÇ : (C : category.{u,v}) ‚Üí
        (D : category.{u,v}) ‚Üí
        ((‚ÑÇùïíùï•Cmp C C D) ‚àò_(Cat) ((‚ÑÇùïíùï•Idn C) √ó_Fun (ùüô_(Cat) (‚ÑÇùïíùï•Hom C D))) ‚àò_(Cat) (PrdId‚ÇÇFst (‚ÑÇùïíùï•Hom C D))) = (ùüô_(Cat) (‚ÑÇùïíùï•Hom C D))  := sorry


-- proving associativity of composition for the twocategory of categories
def ‚ÑÇùïíùï•Ass : (B : category.{u,v}) ‚Üí
          (C : category.{u,v}) ‚Üí
          (D : category.{u,v}) ‚Üí
          (E : category.{u,v}) ‚Üí
          ((‚ÑÇùïíùï•Cmp B C E) ‚àò_(Cat) ((ùüô_(Cat) (‚ÑÇùïíùï•Hom B C)) √ó_Fun (‚ÑÇùïíùï•Cmp C D E))) = (‚ÑÇùïíùï•Cmp B D E) ‚àò_(Cat) ((‚ÑÇùïíùï•Cmp B C D) √ó_Fun (ùüô_(Cat) (‚ÑÇùïíùï•Hom D E))) ‚àò_(Cat) (PrdAss (‚ÑÇùïíùï•Hom B C) (‚ÑÇùïíùï•Hom C D) (‚ÑÇùïíùï•Hom D E)).Fst := sorry



-- twocategory_of_categories
def ‚ÑÇùïíùï• : twocategory := {Obj:= category.{u,v}, Hom := ‚ÑÇùïíùï•Hom, Idn := ‚ÑÇùïíùï•Idn, Cmp := ‚ÑÇùïíùï•Cmp, Id‚ÇÅ := ‚ÑÇùïíùï•Id‚ÇÅ, Id‚ÇÇ := ‚ÑÇùïíùï•Id‚ÇÇ, Ass := ‚ÑÇùïíùï•Ass}


notation C "‚âÉ" D => equivalence ‚ÑÇùïíùï• C D



def TwoIdn {C : twocategory} (X : C.Obj) : (C.Hom X X).Obj := ((C.Idn X).Obj Unit.unit)
notation "ùüè" X => ùüè_(‚ÑÇùïíùï•) X


-- definition of the right triangle identity
-- def AdjId‚ÇÅ (C : category) (D : category) (F : (C ‚Üí_Cat D).Obj) (G : (D ‚Üí_Cat C).Obj) (unit : (C ‚Üí_Cat C).Hom (ùüô_Cat C) (G ‚àò_Cat F)) ( counit : (D ‚Üí_Cat D).Hom (F ‚àò_Cat G) (ùüô_Cat D) ) : Prop := sorry


-- definition of the left triangle identity
-- def AdjId‚ÇÇ (C : category) (D : category) (F : (C ‚Üí_Cat D).Obj) (G : (D ‚Üí_Cat C).Obj) (unit : (C ‚Üí_Cat C).Hom (ùüô_Cat C) (G ‚àò_Cat F)) ( counit : (D ‚Üí_Cat D).Hom (F ‚àò_Cat G) (ùüô_Cat D) ) : Prop := sorry


-- definition of an adjunction

structure adjunction (C : twocategory) where
  Dom : C.Obj
  Cod : C.Obj
  left_adjoint : (C.Hom Dom Cod).Obj
  right_adjoint : (C.Hom Cod Dom).Obj
  unit : (C.Hom Dom Dom).Hom (ùüè_(C) Dom) (G ‚Ä¢_(C) F)
  counit : (C.Hom Cod Cod).Hom (F ‚Ä¢_(C) G) (ùüè_(C) Cod)
--  left_triangle_identity : AdjId‚ÇÅ Dom Cod F G Œ∑ Œµ
--  right_triangle_identity : AdjId‚ÇÇ Dom Cod F G Œ∑ Œµ



def left_adjoint {C : twocategory} (f : adjunction C) : (C.Hom f.Dom f.Cod).Obj := f.left_adjoint


notation f "õ≤î" => left_adjoint f


def right_adjoint {C : twocategory} (f : adjunction C) : (C.Hom f.Cod f.Dom).Obj := f.right_adjoint


notation f "‡•±" => right_adjoint f


/-
def is_adjoint (C : category) (D : category) (F : (C ‚Üí_Cat D).Obj) (G : (D ‚Üí_Cat C).Obj) : Prop := ‚àÉ (Œ∑ : (C ‚Üí_Cat C).Hom (ùüô_Cat C) (G ‚àò_Cat F)), ‚àÉ (Œµ : (D ‚Üí_Cat D).Hom (F ‚àò_Cat G) (ùüô_Cat D)), (AdjId‚ÇÅ C D F G Œ∑ Œµ) ‚àß (AdjId‚ÇÇ C D F G Œ∑ Œµ)
notation F "‚ä£" G => adjoint F G
/-
‚àÉ (G : (D ‚Üí_Cat D).Obj), ‚àÉ (Œ∑ : (C ‚Üí_Cat C).Hom (ùüô_Cat C) (G ‚àò_Cat F)), ‚àÉ (Œµ : (D ‚Üí_Cat D).Hom (F ‚àò_Cat G) (ùüô_Cat D)), (AdjId‚ÇÅ C D F G Œ∑ Œµ) ‚àß (AdjId‚ÇÇ C D F G Œ∑ Œµ)
-/
-/


def is_left_adjoint {C : category} {D : category} (F : Cat.Hom C D) : Prop := sorry

notation F "‚ä£" "-" => is_left_adjoint F


def is_right_adjoint {C : category} {D : category} (G : Cat.Hom D C) : Prop := sorry

notation "-" "‚ä£" G => is_right_adjoint G





-- the first identity law for a monad
-- def monadId‚ÇÅ (C : category) (T : (C ‚Üí_Cat C).Obj) (Œ∑ : (C ‚Üí_Cat C).Hom (Cat.Idn C) (T)) (Œº : (C ‚Üí_Cat C).Hom (T ‚àò_Cat T) (T)) : Prop := sorry -- Œº ‚àò (Œ∑ ‚àô (ùüô T)) = ùüô T


-- the second identity law for a monad
-- def monadId‚ÇÇ (C : category) (T : (C ‚Üí_Cat C).Obj) (Œ∑ : (C ‚Üí_Cat C).Hom (Cat.Idn C) (T)) (Œº : (C ‚Üí_Cat C).Hom (T ‚àò_Cat T) (T)) : Prop := sorry -- Œº ‚àò ((ùüô T) ‚Ä¢ Œ∑) = ùüô T


-- the associativity law for a monad
-- def monadAss (C : category) (T : (C ‚Üí_Cat C).Obj) (Œ∑ : (C ‚Üí_Cat C).Hom (Cat.Idn C) (T)) (Œº : (C ‚Üí_Cat C).Hom (T ‚àò_Cat T) (T)) : Prop := sorry -- Œº ‚àò (Œº ‚Ä¢ (ùüô T)) = Œº ‚àò ((ùüô T) ‚Ä¢ Œº)


-- definition of a monad
structure monad (C : twocategory) where
  Dom : C.Obj
  Fun : (C.Hom Dom Dom).Obj
  Œ∑ : (C.Hom Dom Dom).Hom (ùüè_(C) Dom) Fun
  Œº : (C.Hom Dom Dom).Hom (Fun ‚Ä¢_(C) Fun) Fun
--  Id‚ÇÅ : monadId‚ÇÅ Dom Fun Œ∑ Œº
--  Id‚ÇÇ : monadId‚ÇÇ Dom Fun Œ∑ Œº
--  Ass : monadAss Dom Fun Œ∑ Œº


-- the first comonad identity law for a comonad
-- def comonadId‚ÇÅ (C : category) (T : (C ‚Üí_Cat C).Obj) (Œµ : (C ‚Üí_Cat C).Hom (T) (Cat.Idn C)) (Œî : (C ‚Üí_Cat C).Hom (T) (T ‚àò_Cat T)) : Prop := sorry


-- the second comonad identity law for a comonad
-- def comonadId‚ÇÇ (C : category) (T : (C ‚Üí_Cat C).Obj) (Œµ : (C ‚Üí_Cat C).Hom (T) (Cat.Idn C)) (Œî : (C ‚Üí_Cat C).Hom (T) (T ‚àò_Cat T)) : Prop := sorry


-- the associativity identity law for a comonad
-- def comonadAss (C : category) (T : (C ‚Üí_Cat C).Obj) (Œµ : (C ‚Üí_Cat C).Hom (T) (Cat.Idn C)) (Œî : (C ‚Üí_Cat C).Hom (T) (T ‚àò_Cat T)) : Prop := sorry


-- definition of a comonad
structure comonad (C : twocategory) where
  Cod : C.Obj
  Fun : (C.Hom Cod Cod).Obj
  Œµ : (C.Hom Cod Cod).Hom Fun (ùüè_(C) Cod)
  Œî : (C.Hom Cod Cod).Hom Fun (Fun ‚Ä¢_(C) Fun)
--  Id‚ÇÅ : comonadId‚ÇÅ Dom Fun Œµ Œî
--  Id‚ÇÇ : comonadId‚ÇÇ Dom Fun Œµ Œî
--  Ass : comonadAss Dom Fun Œµ Œî


def MonAdjDom (C : twocategory) (f : adjunction C) : C.Obj := f.Dom


-- def MonAdjFun (C : twocategory) (f : adjunction C) : (C.Hom (MonDom C f) (MonDom C f)).Obj := sorry


-- def MonAdjEta (f : adjunction) : ((MonDom f) ‚Üí_Cat (MonDom f)).Hom (ùüô_Cat (MonDom f)) (MonFun f) := sorry


-- def MonAdjMu (f : adjunction) : ((MonDom f) ‚Üí_Cat (MonDom f)).Hom ((MonFun f) ‚àò_Cat (MonFun f)) (MonFun f) := sorry


-- def MonAdjId‚ÇÅ (f : adjunction) : monadId‚ÇÅ (MonDom f) (MonFun f) (MonEta f) (MonMu f) := sorry


-- def MonAdjId‚ÇÇ (f : adjunction) : monadId‚ÇÇ (MonDom f) (MonFun f) (MonEta f) (MonMu f) := sorry



-- def MonAdjAss (f : adjunction) : monadAss (MonDom f) (MonFun f) (MonEta f) (MonMu f) := sorry


-- the monad corresponding to an adjunction
def MonAdj (C : twocategory) (f : adjunction C) : monad C := sorry --{Dom := MonDom f, Fun := MonFun f, Œº}


notation : 1000 "?_(" C ")" => MonAdj C

-- notation "?" => MonAdj Cat


-- def ComAdjDom (f : adjunction) : category := sorry


-- def ComAdjFun (f : adjunction) : ( (ComDom f) ‚Üí_Cat (ComDom f) ).Obj := sorry


-- def ComAdjEps (f : adjunction) : ( (ComDom f) ‚Üí_Cat (ComDom f) ).Hom (ComFun f) (ùüô_Cat (ComDom f)) := sorry


-- def ComAdjDel (f : adjunction) : ( (ComDom f) ‚Üí_Cat (ComDom f) ).Hom (ComFun f) ((ComFun f) ‚àò_Cat (ComFun f)) := sorry


-- def ComAdjId‚ÇÅ (f : adjunction) : comonadId‚ÇÅ (ComDom f) (ComFun f) (ComEps f) (ComDel f) := sorry


-- def ComAdjId‚ÇÇ (f : adjunction) : comonadId‚ÇÇ (ComDom f) (ComFun f) (ComEps f) (ComDel f) := sorry


-- def ComAdjAss (f : adjunction) : comonadAss (ComDom f) (ComFun f) (ComEps f) (ComDel f) := sorry


-- the monad corresponding to an adjunction
def ComAdj {C : twocategory} (f : adjunction C) : comonad C := sorry


-- ¬ø

notation "¬ø_(" C ")" => ComAdj C

notation "¬ø" => ComAdj ‚ÑÇùïíùï•


-- defining the object component of the codomain of the Eilenberg-Moore adjunction for Cat
/-

-/


-- defining the hom component of the codomain of the Eilenberg-Moore adjunction for Cat
/-

-/


-- defining the identity component of the codomain of the Eilenberg-Moore adjunction for Cat
/-

-/







-- constructing the right adjoint of the Eilenberg-Moore adjunction in Cat on objects
/-

-/


-- constructing the right adjoint of the Eilenberg-Moore adjunction in Cat on morphisms
/-

-/


-- proving the first identity law for the right adjoint of the Eilenberg-Moore adjunction in Cat
/-

-/


-- proving the compositionality law for the right adjoint of Eilenberg-Moore adjunction in Cat
/-

-/


-- assembling the right adjoint of the Eilenberg-Moore adjunction in Cat
/-

-/


-- constructing the left adjoint of the Eilenberg-Moore adjunction in Cat on objects
/-

-/


-- constructing the left adjoint of the Eilenberg-Moore adjunction in Cat on morphisms
/-

-/


-- proving the first identity law for the left adjoint of the Eilenberg-Moore adjunction in Cat
/-

-/


-- proving the compositionality law for the left adjoint of Eilenberg-Moore adjunction in Cat
/-

-/


-- assembling the left adjoint of the Eilenberg-Moore adjunction in Cat
/-

-/


-- constructing the unit of the Eilenberg-Moore adjunction in Cat on objects
/-

-/


-- proving naturality for the unit of the eilenberg moore adjunction unit in Cat
/-

-/



-- constructing the counit of the eilenberg moore adjunction in Cat on objects
/-

-/


-- proving naturality for the counit of the eilenberg moore adjunction in Cat
/-

-/


-- assembling the counit of the eilenberg moore adjunction in Cat
/-

-/


-- the coeilenberg comoore adjunction in Cat triangle identity 1
/-
def
-/


-- the coeilenberg comoore adjunction in Cat triangle identity 1
/-
def
-/


-- assembling the Eilenberg-Moore adjunction in Cat
/-

-/


-- notation for the Eilenberg-Moore categrory in Cat
/-

-/


























-- the co-Eilenberg-co-Moore adjunction in Cat triangle identity 1
/-
def
-/


-- the coeilenberg comoore adjunction in Cat triangle identity 1
/-
def
-/



/-
 ¬°
 -/


-- constructing the canonical map out of the codomain of the eilenberg moore adjunction in Cat
/-

-/


-- notation for the canonical map from eilenberg moore category of the corresponding monad for an adjunction
-- notation "Íúù" => exponential


-- proving the universal property of the eilenberg-moore adjunction in Cat
-- theorem universal_property_of_the_eilenberg_moore_adjunction (œÜ:adjunction) : ‚àÉ!(F : functor (!?œÜ).Cod œÜ.Cod),F ‚Ä¢_(Cat) (!?œÜ)õ≤î = (œÜõ≤î) := sorry



-- notation for the canonical map from co-Eilenberg-co-Moore category of the corresponding monad for an adjunction
-- notation "Íúû" => exponential


-- proving the universal property of the co-Eilenberg-co-Moore adjunction in Cat
/-
def
-/


-- defining monadicity
-- def monadic_adjunction (C : twocategory) (f : adjunction C) : Prop := sorry


-- !M is monadic
/-

-/


-- defining comonadic adjunction
-- def comonadic (C : twocategory) (f : adjunction C) : Prop := sorry


-- comonadicity of a monad
/-

-/


-- ¬°M is comonadic
/-

-/


-- defining a bimonadic adjunction
--structure bimonadic_adjunction where
--  f : adjunction
--  Mon : functor (?f)Íúù  -- need to replace the first Cod with (?f)Íúù
--  Com :




-- constructing the hom component of Adj_(C)
def LadjHom (_ : category) (_ : category) : Type := sorry


-- constructing the identity component of Adj_(‚ÑÇùïíùï•)
def LadjIdn (X : category) : (LadjHom X X) := sorry


-- constructing the composition component of Adj
def LadjCmp (X : category) (Y : category) (Z : category) (_ : LadjHom X Y) (_ : LadjHom Y Z) : (LadjHom X Z) := sorry


-- proving the first identity law in Adj
def LadjId‚ÇÅ (X : category) (Y : category) (f : (LadjHom X Y)):
  (LadjCmp X Y Y f (LadjIdn Y)) = f := sorry


-- proving the second identity law in Ladj
def LadjId‚ÇÇ (X: category) (Y : category) (f : (LadjHom X Y)):
  (LadjCmp X X Y (LadjIdn X) f) = f := sorry


-- proving the associativity law in Adj
def LadjAss
  (W : category)
  (X : category)
  (Y : category)
  (Z : category)
  (f : LadjHom W X)
  (g : LadjHom X Y)
  (h : LadjHom Y Z): (LadjCmp W X Z f (LadjCmp X Y Z g h)) = (LadjCmp W Y Z (LadjCmp W X Y f g) h) := sorry


-- assembling the twocategory of adjunctions
def Ladj : category := {Obj := Cat.Obj, Hom := LadjHom, Idn := LadjIdn, Cmp := LadjCmp, Id‚ÇÅ := LadjId‚ÇÅ, Id‚ÇÇ:= LadjId‚ÇÇ, Ass := LadjAss}

/-
-- constructing the objects in Adj
def RadjObj (T : twocategory) := T.Obj
-/
/-
-- constructing the hom component of Adj_(C)
def left_adjunction (_ : T.Obj) (_ : T.Obj) : Type := sorry
-/
/-
-- constructing the identity component of Adj_(‚ÑÇùïíùï•)
def LadjIdn: (X : category) ‚Üí (LadjHom X X) := sorry
-/
/-
-- constructing the composition component of Adj
def LadjCmp : (X : category) (Y : category) (Z : category) (_ : LadjHom X Y) (_ : LadjHom Y Z) : (LadjHom T X Z) := sorry
-/
/-
-- proving the first identity law in Adj
def LadjId‚ÇÅ :‚àÄ (X Y : category T) (f : (AdjHom T X Y)),
  (AdjCmp T X Y Y f (AdjIdn T Y)) = f := sorry
-/
/-
-- proving the second identity law in Adj
def LadjId‚ÇÇ :  ‚àÄ (X Y : category) (f : (AdjHom X Y)),
  (AdjCmp X X Y (AdjIdn X) f) = f := sorry
-/
/-
-- proving the associativity law in Adj
def LadjAss :‚àÄ (W X Y Z : category) (f : AdjHom W X) (g : AdjHom X Y)
  (h : AdjHom Y Z),
  AdjCmp W X Z f (AdjCmp X Y Z g h) =
  AdjCmp W Y Z f (AdjCmp W X Y f g) h := sorry
-/
/-
-- assembling the twocategory of adjunctions
def Ladj : category := {Obj := category, Hom := LadjHom, Idn := LadjIdn, Cmp := LadjCmp, Id‚ÇÅ := LadjId‚ÇÅ, Id‚ÇÇ:= LadjId‚ÇÇ, Ass := LadjAss}
-/

structure geode where
  Obj : (Cat).Obj
  Pnt : Obj.Obj
  Cmp : Cat.Hom Obj Cat
--  Pul (C : Obj.Obj) (D : Obj.Obj) (F : Obj.Hom C D) : Cat.Hom () ()
--  Œµ
--  Œ∑
--  Id‚ÇÅ
--  Id‚ÇÇ
--
--
--  Bot : Obj.Obj Pnt (Œº.Obj Pnt)
-- Ovr : (X : Obj.Obj) ‚Üí (Y : Obj.Obj) ‚Üí  ... For each object in F : (U/C).Obj, there is a unique map œá_(F) : C ‚Üí ‚àû such that the pullback along œá_(F), of type Hom (U/‚àû) (U/C) sends ‚ä• to F.
-- Existence
-- Uniqueness


-- def Put (Œì : geode.{u+1,v+1}) :


def geodeObj (Œì: geode) : Cat.Obj := Œì.Obj


notation "‚àû_(" Œì ")" => geodeObj Œì


def geodePnt (Œì : geode) : Œì.Obj.Obj := Œì.Pnt


notation : 1000 "*_(" Œì ")" => geodePnt Œì


-- def pullback {Œì : geode} {C : Œì.Obj} {D : Œì.Obj} (F : Œì.Obj.Hom C D) : (Cat.Hom Obj Cat) := Œì.pullback.Hom C D F


-- notation "D(" "p_" "(" ")"  F ")" => pullback Œì


-- def geodeBot (Œì:geode) : Œì.Obj.Obj ‚äõ_(Œì) (Œì.:Œº.Obj Pnt) := Œì.Idn


-- notation : 1000 "‚ä•_(" Œì ")" => geodeBot Œì


-- def geodeOvrType (Œì : geode) : Type := sorry

-- def geodeOvr (Œì:geode) (X : Œì.Obj.Obj) : Œì.geodeOvrType := sorry


-- notation "œá_(" ")"








def Geo : category := sorry







def P (Œì : geode) : Cat.Hom Œì.Obj Œì.Obj := sorry


notation "P_(" Œì ")" => P Œì


-- definition of a geodesic
/-
def geodesic (Œì : representation)
-/


-- defining a map of unitial geodes
/-

-/


-- defining the identity map of a unitial geode
/-

-/


-- defining the identity map of a unitial geode
/-

-/


-- proving the first identity law for composition of unitial geode maps
/-

-/


-- proving the second identity law for composition of unitial geode maps
/-

-/


-- proving the associativity law for composition of unitial geode maps
/-

-/


-- proving the
def IdnGeo : category := sorry


notation : 1000 "ùîæùïñùï†" => IdnGeo


-- Set.Obj
def ùïäùïñùï•Obj : category := Set


--


--


--


-- Set.point


-- Set.universe


-- Set.‚ä•


-- Set.overobject classifier axiom


-- definition of an internal category in a pullback system
-- structure internal_category (Œì : Geo.Obj) (C : Geo.Obj) where
--  Obj : Œì.Obj.Obj
--  Mor : Œì.Obj.Obj
--  Dom : Œì.Obj.Hom Mor Obj
--  Cod : Œì.Obj.Hom Mor Obj
--  Idn : Œì.Obj.Hom Obj Mor
--  Cmp : Œì.M
--
--
--


-- definition of an internal functor in a pullback system
-- def internal_functor ()


-- definition of the identity internal functor in a pullback system
-- def


-- definition of the composition of internal functors in a pullback system
/-

-/


-- definition of the first identity law in a pullback system
/-

-/


-- definition of the second identity law in a pullback system
/-

-/


-- definition of the associativity law in a pullback system
/-

-/


-- internal C-sheaves
/-

-/


-- defining an internal functor between internal C-sheaves
/-

-/


-- defining the identity internal functor of an internal C-sheaf
/-

-/


-- defining the composition of internal functors
/-

-/


-- proving the second identity law for internal functors
/-

-/


-- proving the associativity law for internal functors
/-

-/


-- assembling the category of internal categories in a pullback system
/-

-/


-- notation "D(‚àû-Cat‚ÅÑ" C ")" => D(‚àû-‚ÑÇùïíùï•).Œº.Obj C
-- notation F ": D(‚àû-Cat/" C ")" =>


-- F
-- notation "D(‚àû-Cat‚ÅÑ" C ")" => D(‚àû-‚ÑÇùïíùï•).Œº.Hom C C (ùüô_(Cat)C)


def homotopy_yoneda_principal : Prop := sorry


-- f pullback Id is an internal C-sheaf
/-

-/


-- defining ‚àû-category
inductive infinity_category where
| Pnt : infinity_category


notation "‚àû-category" => infinity_category


-- defining ‚àû-functor (C : ‚àû-category) (D : ‚àû-category)
--inductive infinity_functor (C : ‚àû-category) (D : ‚àû-category) where
--| Idn : (C‚ÇÄ : ‚àû-category) ‚Üí infinity_functor C‚ÇÄ C‚ÇÄ


--notation "‚àû-functor" => infinity_functor


-- defining ‚àû-natural_transformation
--inductive infinity_natural_transformation (C : ‚àû-category) (D : ‚àû-category) (F : ‚àû-functor C D) (G : ‚àû-functor C D) where
--| Idn : infinity_natural_transformation C D F G


-- notation for infinity_natural_transformation


-- defining a homotopy
-- inductive homotopy (C : ‚àû-category) (D : ‚àû-category) (F : ‚àû-functor C D) (G : ‚àû-functor C D) (Œµ : )


-- defining
--def infinity_natural_transformation_up_to_homotopy (C : ‚àû-category) (D : ‚àû-category) (F : ‚àû-functor C D) (G : ‚àû-functor C D) : Type := sorry


def InfCat : category := sorry


notation ‚àû-Cat => InfCat


-- theorem  : Prop := sorry
/-
‚àû-Cat is the universal representation with the fixed point principal.
-/



-- definition of an internal groupoid
/-

-/


-- map of internal groupoids
/-

-/


-- idn for internal groupoids
/-

-/


-- idn for internal groupoids
/-

-/


-- defining the first identity component for internal groupoids
/-

-/


-- defining the second identity component for internal groupoids
/-

-/


-- defining the associativity of internal groupoids
/-

-/


-- assembling internal groupoids
/-

-/



-- def goal‚ÇÅ : ‚Ñï ‚âÖ_(Set) Nat


-- def goal‚ÇÇ : ‚Ñ§ ‚âÖ_(Set) Int


-- def goal‚ÇÉ : D(‚àû-Grpd/S¬π).Hom *_(‚àû-‚ÑÇùïíùï•) ‚Ñù ‚âÖ_(Set) Reals
